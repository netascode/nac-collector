# NDFC.py Developer Documentation Map

## Overview
The `CiscoClientNDFC` class is an NDFC (Nexus Dashboard Fabric Controller) API client that extends `CiscoClientController` to provide comprehensive data collection from Cisco NDFC with support for both single-site and MSD (Multi-Site Domain) fabric architectures.

## Class Architecture

```
CiscoClientController (base class)
    └── CiscoClientNDFC
```

## Method Call Flow Diagram

```
collect_data() [PUBLIC ENTRY POINT]
    ├── authenticate()
    ├── load_endpoints_from_file()
    └── get_from_endpoints_data()
        ├── _detect_msd_fabric_from_endpoints()
        │   └── fetch_data() [inherited from base]
        ├── _extract_fabric_id_from_endpoints()
        │   ├── _process_endpoint_for_msd_fabrics() [if MSD]
        │   └── _process_endpoint_single_site() [if single-site]
        └── [For each endpoint]:
            ├── _process_msd_endpoint() [if MSD_Fabric_Associations]
            ├── _process_endpoint_for_msd_fabrics() [if MSD and not MSD_Fabric_Associations]
            │   ├── _is_msd_root_fabric()
            │   ├── _update_fabric_id_for_current_fabric()
            │   └── _process_endpoint_single_site()
            └── _process_endpoint_single_site() [if single-site]
                ├── _process_policies_endpoint_with_filtering() [if Policies endpoint]
                │   ├── _extract_serial_numbers_from_switches()
                │   ├── _filter_by_discovered_Serial_numbers()
                │   ├── _filter_autogenerated_policies()
                │   └── _filter_specyfic_template_policies()
                ├── fetch_data() [inherited from base]
                ├── _fix_escaped_json_in_data()
                └── _process_children_endpoints() [if children exist]
                    ├── _process_network_attachments() [if Network_Configuration]
                    │   ├── fetch_data() [inherited from base]
                    │   └── _process_attachment_data()
                    └── _process_vrf_attachments() [if VRF_Configuration]
                        ├── fetch_data() [inherited from base]
                        └── _process_attachment_data()
```

## Detailed Method Documentation

### Public Methods (Entry Points)

#### `__init__(self, **kwargs)`
**Purpose**: Initialize NDFC Controller client with fabric-specific configuration
**Called by**: External instantiation
**Calls**: `super().__init__(**kwargs)`
**Key attributes initialized**:
- `fabric_name`: Target fabric name
- `is_msd_fabric`: Boolean flag for MSD detection
- `msd_topology`: Dictionary storing MSD fabric relationships
- `fabric_id`: Fabric ID for API endpoint variable replacement
- `exclude_templates`: List of template names to exclude from policy filtering

#### `authenticate(self) -> bool`
**Purpose**: Authenticate with NDFC using /login endpoint (ONLY hardcoded endpoint)
**Called by**: `collect_data()`
**Calls**: None (uses httpx directly)
**Returns**: Boolean indicating authentication success
**Note**: Sets up HTTP client with Bearer token and AuthCookie

#### `collect_data(self, endpoints_file: str) -> Dict[str, Any]`
**Purpose**: Main entry point for data collection from NDFC
**Called by**: External clients
**Calls**: 
- `authenticate()`
- `load_endpoints_from_file()`
- `get_from_endpoints_data()`
**Returns**: Dictionary with collected data organized by endpoint name

#### `get_from_endpoints_data(self, endpoints_data: List[Dict[str, Any]]) -> Dict[str, Any]`
**Purpose**: Process endpoints data from YAML configuration
**Called by**: `collect_data()`
**Calls**: 
- `_detect_msd_fabric_from_endpoints()`
- `_extract_fabric_id_from_endpoints()`
- Various endpoint processing methods
**Returns**: Dictionary with processed endpoint data

### MSD Fabric Detection and Processing

#### `_detect_msd_fabric_from_endpoints(self, endpoints_data: List[Dict[str, Any]])`
**Purpose**: Detect if fabric is MSD root by analyzing MSD_Fabric_Associations
**Called by**: `get_from_endpoints_data()`
**Calls**: `fetch_data()` (inherited)
**Logic**: 
- Looks for MSD_Fabric_Associations endpoint
- Builds MSD topology tree (root + members)
- Sets `is_msd_fabric = True` if fabric_name is MSD root

#### `_extract_fabric_id_from_endpoints(self, endpoints_data: List[Dict[str, Any]], result: Dict[str, Any])`
**Purpose**: Extract fabric ID from Fabric_Configuration for endpoint variable replacement
**Called by**: `get_from_endpoints_data()`
**Calls**: 
- `_process_endpoint_for_msd_fabrics()` (if MSD)
- `_process_endpoint_single_site()` (if single-site)
**Sets**: `self.fabric_id` for use in {{fabricID}} placeholder replacement

#### `_process_msd_endpoint(self, endpoint: Dict[str, Any], result: Dict[str, Any])`
**Purpose**: Process MSD-specific endpoints (like MSD_Fabric_Associations)
**Called by**: `get_from_endpoints_data()` for MSD_Fabric_Associations endpoint
**Calls**: 
- `fetch_data()` (inherited)
- `_fix_escaped_json_in_data()`

#### `_process_endpoint_for_msd_fabrics(self, endpoint: Dict[str, Any], result: Dict[str, Any])`
**Purpose**: Process endpoint for all fabrics in MSD deployment (root + members)
**Called by**: `get_from_endpoints_data()` for MSD fabrics
**Calls**: 
- `_is_msd_root_fabric()`
- `_update_fabric_id_for_current_fabric()`
- `_process_endpoint_single_site()`
**Logic**: Iterates through all MSD fabrics, applying endpoint-specific filtering rules

#### `_is_msd_root_fabric(self, fabric_name: str) -> bool`
**Purpose**: Check if given fabric is MSD root (fabricType: "MSD")
**Called by**: `_process_endpoint_for_msd_fabrics()`
**Returns**: Boolean indicating if fabric is MSD root

#### `_update_fabric_id_for_current_fabric(self, result: Dict[str, Any])`
**Purpose**: Update fabric_id for current fabric context from Fabric_Configuration data
**Called by**: `_process_endpoint_for_msd_fabrics()`
**Updates**: `self.fabric_id` for current fabric context

### Single-Site Endpoint Processing

#### `_process_endpoint_single_site(self, endpoint: Dict[str, Any], result: Dict[str, Any])`
**Purpose**: Process endpoint for single-site fabric or individual MSD member
**Called by**: 
- `get_from_endpoints_data()` (single-site)
- `_process_endpoint_for_msd_fabrics()` (MSD members)
**Calls**: 
- `_process_policies_endpoint_with_filtering()` (if Policies endpoint)
- `fetch_data()` (inherited)
- `_fix_escaped_json_in_data()`
- `_process_children_endpoints()` (if children exist)
**Features**: 
- URL placeholder replacement (%v for fabric_name, {{fabricID}} for fabric_id)
- Child endpoint processing for hierarchical data

### Policy Filtering Pipeline

#### `_process_policies_endpoint_with_filtering(self, endpoint, endpoint_dict)`
**Purpose**: Process Policies endpoint with advanced client-side filtering
**Called by**: `_process_endpoint_single_site()` for Policies endpoint
**Calls**: 
- `fetch_data()` (inherited)
- `_fix_escaped_json_in_data()`
- `_extract_serial_numbers_from_switches()`
- `_filter_by_discovered_Serial_numbers()`
- `_filter_autogenerated_policies()`
- `_filter_specyfic_template_policies()`
**Purpose**: Implements complex filtering pipeline to reduce policy data to relevant subset

#### `_extract_serial_numbers_from_switches(self, discovered_switches_data)`
**Purpose**: Extract serial numbers from Discovered_Switches data for policy correlation
**Called by**: 
- `_process_policies_endpoint_with_filtering()`
- `_filter_by_discovered_Serial_numbers()`
**Returns**: List of serial numbers from discovered switches

#### `_filter_by_discovered_Serial_numbers(self, data, endpoint_dict, serial_fields=None, match_any=True)`
**Purpose**: Filter items to include only those referencing discovered switch serial numbers
**Called by**: `_process_policies_endpoint_with_filtering()`
**Calls**: `_extract_serial_numbers_from_switches()`
**Features**: 
- Recursive serial number detection
- Flexible field path specification
- Configurable matching logic (any/all fields)

#### `_filter_autogenerated_policies(self, policies_data)`
**Purpose**: Filter out policies with autoGenerated = true
**Called by**: `_process_policies_endpoint_with_filtering()`
**Returns**: List of non-autogenerated policies

#### `_filter_specyfic_template_policies(self, policies_data, template_names)`
**Purpose**: Filter out policies based on specific template names (e.g., Default_VRF_Universal)
**Called by**: `_process_policies_endpoint_with_filtering()`
**Uses**: `self.exclude_templates` from YAML filters configuration
**Returns**: List of policies not based on excluded templates

### Data Processing Utilities

#### `_fix_escaped_json_in_data(self, data)`
**Purpose**: Recursively fix escaped JSON strings in vrfTemplateConfig and networkTemplateConfig fields
**Called by**: 
- `_process_msd_endpoint()`
- `_process_endpoint_single_site()`
- `_process_policies_endpoint_with_filtering()`
**Modifies**: Data in-place to parse JSON strings into objects

### Children Endpoint Processing

#### `_process_children_endpoints(self, parent_endpoint, endpoint_dict)`
**Purpose**: Process child endpoints for hierarchical data structures
**Called by**: `_process_endpoint_single_site()`
**Calls**: 
- `_process_network_attachments()` (if Network_Configuration)
- `_process_vrf_attachments()` (if VRF_Configuration)

#### `_process_network_attachments(self, parent_endpoint, endpoint_dict)`
**Purpose**: Process Network_Attachments for deployed networks in Network_Configuration
**Called by**: `_process_children_endpoints()`
**Calls**: 
- `fetch_data()` (inherited)
- `_process_attachment_data()`
**Logic**: Only processes networks with networkStatus = "DEPLOYED"

#### `_process_vrf_attachments(self, parent_endpoint, endpoint_dict)`
**Purpose**: Process VRF_Attachments for deployed VRFs in VRF_Configuration
**Called by**: `_process_children_endpoints()`
**Calls**: 
- `fetch_data()` (inherited)
- `_process_attachment_data()`
**Logic**: Only processes VRFs with vrfStatus = "DEPLOYED"

#### `_process_attachment_data(self, attachment_data)`
**Purpose**: Process raw attachment data from API response into consistent format
**Called by**: 
- `_process_network_attachments()`
- `_process_vrf_attachments()`
**Returns**: Processed list of attachment items
**Handles**: Various API response structures (lanAttachList, data wrappers, etc.)

### Configuration Loading

#### `load_endpoints_from_file(self, endpoints_file: str) -> List[Dict[str, Any]]`
**Purpose**: Load endpoints and filters configuration from YAML file
**Called by**: `collect_data()`
**Sets**: `self.exclude_templates` from filters configuration
**Returns**: List of endpoint configurations from YAML

## Key Design Patterns

### 1. MSD vs Single-Site Handling
The code implements a branching pattern based on `is_msd_fabric` flag:
- **MSD Root**: Processes endpoints for all fabrics (root + members) with specific filtering rules
- **Single-Site**: Processes endpoints only for the specified fabric

### 2. Endpoint Processing Pipeline
Each endpoint follows a consistent processing pattern:
1. URL placeholder replacement
2. Data fetching via inherited `fetch_data()`
3. JSON escape fixing
4. Endpoint-specific filtering (especially for Policies)
5. Child endpoint processing (if applicable)

### 3. Policy Filtering Pipeline
Policies undergo a multi-stage filtering process:
1. Serial number correlation with discovered switches
2. Autogenerated policy exclusion
3. Template-based exclusion
4. Result aggregation with metadata

## Extension Points for New Features

### Adding New Endpoint Types
1. **Add to YAML**: Define new endpoint in endpoints YAML file
2. **Special Processing**: If needs special handling, add logic in `_process_endpoint_single_site()`
3. **Filtering**: If needs filtering, create new `_filter_*` method and call from processing method

### Adding New Filtering Criteria
1. **Create Filter Method**: Follow pattern of `_filter_*` methods
2. **Integration**: Call from appropriate endpoint processing method
3. **Configuration**: Add filter configuration to YAML filters section

### Adding Child Endpoints
1. **YAML Configuration**: Add children array to parent endpoint
2. **Processing Logic**: Add case in `_process_children_endpoints()`
3. **Data Integration**: Create specific `_process_*_attachments()` method

### MSD Fabric Extensions
1. **Topology Detection**: Modify `_detect_msd_fabric_from_endpoints()` for new MSD patterns
2. **Fabric-Specific Logic**: Add conditions in `_process_endpoint_for_msd_fabrics()`
3. **Member Filtering**: Extend logic in MSD processing methods

## Common Patterns for Development

### Adding a New Filter
```python
def _filter_new_criteria(self, data, criteria_list):
    """Filter data based on new criteria."""
    # Follow existing filter patterns
    # Return filtered list
    pass
```

### Adding Special Endpoint Processing
```python
# In _process_endpoint_single_site():
if endpoint_name == "New_Endpoint":
    self._process_new_endpoint_with_special_logic(endpoint, result)
    return
```

### Adding Child Endpoint Support
```python
# In _process_children_endpoints():
elif parent_name == "New_Parent_Configuration":
    self._process_new_attachments(parent_endpoint, endpoint_dict)
```

This documentation provides a comprehensive map of the NDFC.py codebase, showing how each method interconnects and where new functionality can be safely added while maintaining the existing architecture patterns.
